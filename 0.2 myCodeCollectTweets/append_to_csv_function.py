import csv# For parsing the dates received from twitter in readable formatsimport datetimeimport dateutil.parserimport unicodedata# For parsing the dates received from twitter in readable formatsdef append_data_to_csv(json_response, fileName):    #A counter variable    counter = 0    #Open OR create the target CSV file    csvFile = open(fileName, "a", newline="", encoding='utf-8')    csvWriter = csv.writer(csvFile)    #Loop through each tweet    for tweet in json_response['data']:                # We will create a variable for each since some of the keys might not exist for some tweets        # So we will account for that        # 1. Author ID        author_id = tweet['author_id']                # 2. Time created        created_at = dateutil.parser.parse(tweet['created_at'])        # 3. Geolocation        if ('geo' in tweet):               geo = tweet['geo']['place_id']        else:            geo = " "        # 4. Tweet ID        tweet_id = tweet['id']        # 5. Language        lang = tweet['lang']        # 6. Tweet metrics        retweet_count = tweet['public_metrics']['retweet_count']        reply_count = tweet['public_metrics']['reply_count']        like_count = tweet['public_metrics']['like_count']        quote_count = tweet['public_metrics']['quote_count']        # 7. source        source = tweet['source']        # 8. Tweet text        text = tweet['text']                                # Assemble all data in a list        res = [author_id, created_at, geo, tweet_id, lang, like_count, quote_count, reply_count, retweet_count, source, text]                # Append the result to the CSV file        csvWriter.writerow(res)        counter += 1    # When done, close the CSV file    csvFile.close()    # Print the number of tweets for this iteration    print("# of Tweets added from this response: ", counter)            def append_includes_to_csv(json_response, fileName):    if 'places' not in json.response['includes']:        print(-No place data in the response!')        return    fite.exists = os. path. isf ite (f iteNaiae)        # Open OR create the target CSV file    with openCfiteNane, "a", newtine="", encodings'utf-8') as csvFite:        csvWriter = csv.writer(csvFite)                 # check if file exists, write header only once        if not fite.exists:            csvWriter.writerow(                ['id', 'name*, 'fuLL.name', 'country', 'country.code', 'ptace.type', 'geotyge', 'min.bbox.Lon'                'niin.bbox.Lat', 'max.bbox.Lon', 'max.bbox.Lat', 'properties'])                counter = 0            for place in json.response['includes']['places']:            id = place['id']            nane = place['narae'J            full.nane = placet'fuLL.name']            country = place['country']            country.code = place['country.code']            place.type = place['ptace.type']            geotype = placefgeo'lt'type']            min.bbox.Lon = place['geo']['bbox'][0]            min.bbox.Lat = place['geo']['bbox'][1]                 max_bbox_Lon = place['geo']['bbox'][2]            max_bbox_Lat = place['geo']['bbox'][3]             properties = placet'geo']['properties']                        res = [id, name, fufl.name, country, country.code, place.type, geotype, min_bbox_Lon, min.bbox.Lat, max_bbox_lon, max_bbox_tat, properties]            # Append the result to the CSV file             csvWriter.writerow(res)             counter += 1                # Print the number of tweets for this iteration         print("# of places added from this response: {}â– ".format(counter))    # When done, close the CSV file    csvFile.close()    # Print the number of tweets for this iteration    print("# of Tweets added from this response: ", counter) 